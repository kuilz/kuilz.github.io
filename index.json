[{"content":" update_time: 2024-12-21 About Now Page 为什么添加这样一个页面呢？灵感来源于now page。对我来说，本页面主要有两个作用： 假设有许久不见的老友问我近况，我可以直接把这个链接抛给他。 提醒一下自己近期在做什么、想做什么，免得连自己都忘了。 Now **冲刺2024KPI：**试图在最后十天拯救一事无成的一年。 学习MySQL：在看《MySQL实战45讲》。 学习分布式大模型推理和微调：分布式计算+大模型推理和微调。Petals、vLLM和LoRA。 跑步：每周4次，每次6km。每周4次为完美周，每月100km为完美月，12月要达成第一个完美月。 提升睡眠质量：关注入睡时间点（23:30）、入睡时间（\u003c30min）、入睡规律性（$\\pm$30min）、总睡眠时长（7~7.5h）。最近又不能在30min内入睡了，需要认真对待睡眠。 记账：保持记账的好习惯，了解消费状况。 读书： 主题阅读【本季度主题：理财金融经济】（无序列表，记录历史阅读和当前阅读，便于总览） 本季度赶紧结束吧，好像换个主题啊（下一季度：计算机科学与技术😍） 《小岛经济学》 《激荡三十年》 《小镇金融学》 《金融通识课》-陈志武 《国富论》 《资本论》 《时势》 《原则：应对变化中的世界秩序》 《拯救华尔街》 《小狗钱钱》 《富爸爸穷爸爸》 《牛奶可乐经济学》 随性阅读（无序列表，仅记录当前阅读，完整阅读记录见微信读书） 《Atomic Habits》 ","title":"Now","uri":"/now/"},{"content":"打算捡起来落下了一年多的夜跑的习惯。\n2024 6月，你好 2024-06-30 Keep Running\n2024-06-29 What I Read Today\n是什么造成了中国软件产业的悲剧\n2024年，希望中国软件一切向好\n这两篇文章算是一个系列，我先读的第一篇。作者认为中国缺乏优秀的软件，主要有以下几点原因（按我个人喜好摘录和理解的，建议看原文）：\n信息系统大行其道。 大部分软件都是应用型、定制化的信息系统。（读到这我就觉得作者想要的优秀软件可能特指基础软件，比如操作系统、数据库、中间件等，后来发现果真如此。） 政府的羊毛最好撸。 有些钱是不得不花的，所以有途径挣到这笔钱的人就可以轻轻松松养活公司一家老小。PS: 不过2024的回款可不好收，不知道软件行业有没有“恶意讨薪”的说法（🐶保命） 互联网公司的技术妄念。 整天嚷嚷着创新，其实还是开源软件的缝合怪。 其实第一篇文章通篇读下来基本没有我赞同的点，甚至上面摘录的这几点我也不完全赞同，但我觉得这是一个好问题。之所以不完全赞同，是因为我觉得作者把问题混淆了，他理想中的软件可能是优秀的基础软件，我觉得即便是粗略的划分，也能把应用软件和基础软件分开。因此一直吐槽应用软件怎么怎么样，不如直接问“是什么造成了中国基础软件产业的悲剧”。就像第三点，互联网大厂搞技术创新实现高并发、高可用本质还是为了挣钱呀，而且他挣得主要是C端用户的钱，单纯追求技术反而是妄念，搞钱才是正事，高基础软件不是强人所难吗hhh，but能力越大，责任越大，多干点也是理所应得的。那么能说应用软件就比基础软件低一等吗？我觉得也不是，一方面优秀的应用软件，比如淘宝（主要指后台）、TikTok创造了巨大的价值，另一方面，它们也有世界领先的技术，比如淘宝大促期间的高并发能力，TikTok的推荐算法等等。\n后面读了作者的第二篇文章，很多地方都比较有共鸣。比如近几年涌现出大量数据库的初创公司、云计算的价格战、开源软件修改许可证等（最近的gitcode事件是真的恶心）。不过第六点有点怪，以至于我觉得作者是不是在反讽，可能是他对基础软件的执念太强了吧hhh\n最后，没想到《国王排名》这部烂片😭竟然是21年播出的了，过得真快啊。\nKeep Running\n今儿状态不错，最后500m还稍微提了点速😎\n2024-06-28 What I Read Today\nThe Intellectual Obesity Crisis\n跑完步总想喝一些甜的，在我拿着旺仔打开阮大的周刊时恰好看到这篇文章：The Intellectual Obesity Crisis。作者认为信息就像糖一样，使人上瘾，二者有一些简单的共同点：\n研究表明，信息和糖都会促进多巴胺的产生，让人感到快乐。 信息和糖都曾是宝贵的稀缺品，但工业革命使我们实现了糖自由，信息革命使得信息爆发。 起码从体感上，我觉得我个人就处于信息上瘾的状态：早上睁开眼就控制不住打开即时通信软件，尽管我知道那里面一定没什么信息，晚上睡觉前手指不停地滑动屏幕，一个接一个地看视频，直到疲惫不堪地睡去。\n所以最近我会刻意减少和信息的接触，包括把手机放抽屉里，偶尔试着不带耳机走路，睡前手机关机，留出一段时间啥都不干然后入睡。这些行为都让我觉得更加轻松清醒了。\n我的想法：\n人的身体进化的太慢了，我们和吟诗作赋的古人，甚至茹毛饮血的古人类，在生理结构上应该没有太大差异，当然也包括大脑。而科技是爆发式发展的，过去十年的变化一定超过过去五十年，未来五年又会发生翻天覆地的改变。身体是个老古董，面对新生事物和机制暴露出缺陷是很正常的。正确看待，了解机制，做出选择，采取措施即可。 作者文末说了几种避免出现智力肥胖的机制，其中写作这一点我非常赞同。能促进输出的东西，质量一定不会太差。 Keep Running\n2024-06-24 What I Read Today\nWith AI, Anyone Can Be a Coder Now | Thomas Dohmke | TED\nGithub CEO Thomas认为LLM改变了人机交互的方式，或者说自然语言成了一种新的编程语言，任何人都可以直接通过自然语言和计算机进行交互，实现自己的创意。他说目前Github约有1亿用户，即全球有1%的人可以进行软件开发，在未来5年左右，开发者的数量会激增到全球人口的10%。\n我的想法：\n自然语言是一种很好的人机交互的方式，但我觉得人机交互的最终形态应该是脑机接口，从意念直接到行为，不需要语言作为媒介。 假如人人都可以写代码，那么我们可能会需要这样一种产品：它可以使硬件（计算、网络、存储）和基础软件（网关、数据库、防火墙）变得透明，使得所有代码都可以方便的运行。会不会和云原生操作系统有关？ Keep Running\n2024-06-23 2024-06-22 2024-06-21 提升实力，放弃幻想。\n2024-06-20 2024-06-18 2024-06-15 2024-06-14 2024-06-13 2024-06-12 2024-06-03 2024-06-02 最近一周除了下雨天，每天都出去跑了一下，也愈发觉得自己现在的身体状态大不如前😂\n作息规律，适当运动✊🏻\n2024-06-01 5月，有凉风 2024-05-30 又下雨啦，为了弥补特殊天气带来的🏃🏻‍♂️频率的降低，打算后面适当增加🏃🏻距离。\n今天发现了一个好玩的东西：rustlings，一个用于熟悉rust语言的小工具，第一次觉得debug也可以这么快乐hhh，非常适合没有学过rust的同学。\n2024-05-29 2024-05-28 2024-05-27 “一场大雨毁了我的跑步梦”😭\n从实验室回来的路上看到了这把掀翻在地的雨伞。（对了，伞后面这片普普通通的绿植，名字叫做红叶石楠。因为每天都要见到它，所以我觉得我们有必要认识一下。\n2024-05-26 2024-05-25 ","title":"大学生自救计划——跑步打卡","uri":"/post/2024/05/running/"},{"content":"这篇文章本来还是按照上一篇的风格写的，但发现太耗费精力的，于是变成了最简单粗暴的版本。后面需要学会在有趣与直接、丰富与简洁之间找到平衡。 单例模式（Singleton Pattern）是一种设计模式，用于确保一个类只有一个实例，并提供对该实例的全局访问点。 单例模式的使用场景大多和系统资源相关，比如缓存、线程池和数据库连接池等，在这些场景中，如果实例化多个对象，可能会出现程序执行结果不一致或者系统资源耗费严重的问题。 Intent The Singleton Pattern ensures a class has only one instance, and provides a global point of access to it. Class Diagram 使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。 私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。 Implementation 懒汉式-线程不安全 Singleton class: package org.kuilz.SingletonPattern.LazyUnsafe; public class Singleton { private static Singleton singleton; private Singleton(){} public static Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; } } SingletonTest class: package org.kuilz.SingletonPattern.LazyUnsafe; public class SingletonTest { public static void main(String[] args) { int numThreads = 10; Thread[] threads = new Thread[numThreads]; for (int i = 0; i \u003c numThreads; i++) { threads[i] = new Thread(new MyRunnable()); threads[i].start(); } } static class MyRunnable implements Runnable { @Override public void run() { Singleton singleton = Singleton.getInstance(); System.out.println(\"Thread: \" + Thread.currentThread().getId() + \", Singleton hashCode: \" + singleton.hashCode()); } } } Output: Thread: 26, Singleton hashCode: 43190021 Thread: 27, Singleton hashCode: 43190021 Thread: 22, Singleton hashCode: 43190021 Thread: 28, Singleton hashCode: 43190021 Thread: 23, Singleton hashCode: 43190021 Thread: 29, Singleton hashCode: 43190021 Thread: 24, Singleton hashCode: 43190021 Thread: 21, Singleton hashCode: 43190021 Thread: 20, Singleton hashCode: 1102734481 Thread: 25, Singleton hashCode: 2046608170 这是我们最容易想出来的实现，但多线程并发时，可能有多个线程进入 if 代码块，从而实例化多个对象，因此这种方法没啥用。为了解决该问题，我们可以想到几个解决方案： 定义时就new，这样类加载时就会实例化对象。 getter方法上添加synchronized关键字，保证每次只有一个线程进入。 这两种方法都是线程安全的，分别对应饿汉式-线程安全和懒汉式-线程安全。这名字起了不如不起🥲，反而让人记不住。我们只需要记住懒汉式指的是lazy加载，需要用到时才实例化。饿汉式指的是eager加载，类加载器加载类时就进行实例化。 饿汉式-线程安全 package org.kuilz.SingletonPattern.EargeSafe; public class Singleton { private static Singleton singleton=new Singleton(); private Singleton(){} public static Singleton getInstance() { return singleton; } } 这种方法的缺点是就算你用不到该对象，也会实例化出来，所以适用于资源充裕的情况。 懒汉式-线程安全 package org.kuilz.SingletonPattern.LazySafe; public class Singleton { private static Singleton singleton; private Singleton(){} public static synchronized Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; } } synchronized可能会使性能下降100倍，而且我们其实只有第一次访问getter时需要加锁，所以这种写法极大的降低了性能，适用于对性能要求不高的情况。 怎么解决呢？可以自然地想到，那就不对整个函数使用synchronized加锁了，只对new 对象的代码块用就好了，于是引出了双重校验锁方法。 双重校验锁-线程安全 package org.kuilz.SingletonPattern.DoubleCheckSafe; public class Singleton { private volatile static Singleton singleton; private Singleton(){} public static Singleton getInstance() { if (singleton == null) { synchronized (Singleton.class){ if(singleton==null){ singleton = new Singleton(); } } } return singleton; } } 看到上面的代码你可能会有两个疑问。 为什么成员变量前加了个volatile？这是因为JVM具有指令重排的特性，singleton = new Singleton();这条语句可能会按照这样的顺序执行：①分配地址空间，②引用指向这块地址，③对象进行初始化。这样的话，可能对象还没有完成初始化就被某个线程拿到了，而volatile可以禁止指令重排。 为什么判断两次singleton是否为null？因为第一个if没加锁，可能有多个线程同时进入。如果没有第二个if判断，尽管使用了synchronized，已经进入的线程会依次实例化一个对象。 双重校验锁方法有什么问题吗？还是有的，它无法适用反射、序列化的场景。下面将介绍单例模式的最佳实践：枚举。 枚举实现 package org.kuilz.SingletonPattern.EnumSafe; public enum Singleton { UNIQUE_INSTANCE; } 枚举是单例模式的最佳实践。 看到这你是不是觉得前面的都白学了？其实并没有，经过前面拍拍脑袋想出来线程不安全的懒汉式，到一步步改进实现其他方法，这个过程我们对单例模式的理解更加深刻了。 ps：本文源码放在github上，配合博客食用更佳。 JDK java.lang.Runtime#getRuntime() java.awt.Desktop#getDesktop() java.lang.System#getSecurityManager() References Code Repo 《Head First Design Pattern》 Java 全栈知识体系 ","title":"设计模式——单例模式","uri":"/blog/2024/05/design_pattern_singleton_pattern/"},{"content":"kuilz原创性自我评估(KCSE)：10% 知道Docker很好用，但一直没养成用它的习惯，所以基本命令都记不清，然后就更不怎么用，恶性循环。。。打算以本文为契机，将Docker正式纳入我的工作流。\nBasic Concept Docker\nDocker is a tool that allows developers, sys-admins etc. to easily deploy their applications in a sandbox (called containers) to run on the host operating system i.e. Linux. The key benefit of Docker is that it allows users to package an application with all of its dependencies into a standardized unit for software development. Unlike virtual machines, containers do not have high overhead and hence enable more efficient usage of the underlying system and resources.\n简单来说，Docker就是一个可以方便地把应用程序部署到沙盒（容器）中的工具。沙盒在宿主机上运行，而又与宿主机保持一定的隔离性。我们可以把应用程序的相关依赖全部打包成到一个Docker镜像里，使用镜像实例化Docker容器，方便地进行部署。\nImage and Container\nImages - The blueprints of our application which form the basis of containers.\nContainers - Created from Docker images and run the actual application.\n镜像和容器是Docker中最重要的两个概念，以类和对象进行类比，镜像就像是一个类，容器就像是这个类实例化得到的对象。\nDocker Cheat Sheet (Figure) 我们可以使用pull命令从Container Registry下载镜像，然后使用run命令创建容器并运行。也可以编写Dockerfile，使用build命令构建镜像。或者使用save和load命令实现镜像文件的保存与加载。本文最有价值的就是这张图了， 这张图是参考 10分钟快速学会docker 画的，该视频言简意赅，干净利落，强烈推荐。\nDocker Cheat Sheet (List) 本文只介绍最常见的用法和参数，各个命令完整的、详细的参数可以参考：Docker 命令大全。\n我喜欢像下面这样把各个命令/方法的Comment和Usage全放在一个代码块里，不要啰里八嗦的介绍，看着是不是很清爽，希望你也能够喜欢😄。对了，如果本机没有安装Docker的话，可以在Play with Docker上练习这些命令。\n# 拉取镜像到本地，TAG用于指定版本号，不写的话默认使用lastest docker pull IMAGE_NAME[:TAG] # 列出本地所有镜像 docker images # 删除IMAGE docker rmi IMAGE # 强制删除IMAGE docker rmi -f IMAGE # 创建容器并启动 docker run IMAGE # 创建容器，在后台启动 docker run -d IMAGE # 指定容器名称 docker run -d --name CONTAINER_NAME IMAGE # 指定端口映射 docker run -d -p HOST_PORT:CONTAINER_PORT IMAGE # 指定挂载数据卷 docker run -d -v HOST_DIR:CONTAINER_DIR IMAGE # 列出当前正在运行的容器 docker ps # 列出所有容器 docker ps -a # 在容器中执行命令 docker exec CONTAINER COMMAND # 在容器中执行一个bash shell docker exec -it CONTAINER bash # 停止容器 docker stop CONTAINER # 启动容器 docker start CONTAINER # 在后台启动容器 docker start -d CONTAINER # 强制停止容器 docker kill CONTAINER # 删除CONTAINER docker rm CONTAINER # 强制删除CONTAINER docker rm -f CONTAINER # 创建新镜像 docker commit CONTAINER NEW_IMAGE_NAME # 使用Dockerfile构建镜像 docker build -t IMAGE_NAME PATH_TO_DOCKERFILE # 保存镜像到归档文件 docker save -o OUTPUT_FILE.tar IMAGE # 加载归档文件中的镜像 docker load -i INPUT_FILE.tar References 10分钟快速学会docker docker-curriculum Docker 命令大全 Play with Docker ","title":"Docker基本使用","uri":"/blog/2024/05/docker-intro/"},{"content":"前言 最近闲暇时在看《Head First Design Pattern》这本书，感觉蛮有意思的，不妨记录一下。 叠甲：笔者才疏学浅，水平有限，错漏之处，欢迎指出。 正文 面向对象设计有几个基本特性：抽象、封装、继承和多态。在设计过程中，我们会把一个事物的属性和方法封装起来，成为一个类，如果这些属性和方法是多个类通用的，我们还会把通用的部分单独封装起来，作为父类，从而实现代码复用。但一个类继承父类实现代码复用的同时，也有了一些限制： 父类有的行为它都会有。 它的行为不能动态改变。 这样说可能难以理解，不如从我们最先接触面向对象时的例子开始，让我们把记忆拉回到大一大二，看看熟悉的猫吃鱼，狗吃肉，奥特曼爱打小怪兽。 Animal class: package org.kuilz.StrategyPattern.original; public class Animal { public String name; public Animal(){} public Animal(String name){ this.name=name; } public void eat(){ System.out.println(name+\": \"+\"I am eating something.\"); } } Cat class: package org.kuilz.StrategyPattern.original; public class Cat extends Animal{ public Cat(){} public Cat(String name){ super(name); } @Override public void eat() { System.out.println(name+\": \"+\"I am eating fish.\"); } } Dog class: package org.kuilz.StrategyPattern.original; public class Dog extends Animal{ public Dog(){} public Dog(String name){ super(name); } @Override public void eat() { System.out.println(name+\": \"+\"I am eating meat.\"); } } Main function: package org.kuilz.StrategyPattern.original; public class Demo { public static void main(String[] args) { Animal animal = new Animal(\"X-animal\"); animal.eat(); Animal cat = new Cat(\"Garfield\"); cat.eat(); Animal dog = new Dog(\"Snoopy\"); dog.eat(); } } Output: X-animal: I am eating something. Garfield: I am eating fish. Snoopy: I am eating meat. 上面的代码非常简单，Cat和Dog继承了Animal，实现了自己的eat()方法。那么我刚刚说的两个问题体现在哪里呢？ 1. 父类有的行为它都会有。 2. 它的行为不能动态改变。 先来看第一条，“父类有的行为它都会有”，继承的特点就是这样，这有什么问题吗？问题出现在我们需要添加新的方法时。 比如老板说，动物怎么可以只会吃东西呢，还要能陪主人玩。然后你就在Animal类中添加一个play()方法，结果发现狗子是挺乐意陪主人玩的，但有些高冷的猫主子并不认为自己需要这个方法，可只要是继承自Animal类的子类都要有该行为，这就出现了问题。 重点说说第二条，身为大学牲的你天天吃食堂，不出一个月就腻了，狗子也想换换口味，不想天天吃肉，也想啃啃骨头或者常常鱼的味道。很遗憾，刚刚的设计不能实现，也就是说Dog类的eat()方法定义好之后就不能再改变。（你别说把食物作为参数传进去就行了，如果不同动物的eat()方法只是字符串不同的话，那我们连Dog和Cat都不需要定义，这里的eat()其实是很复杂的行为😎） 解决方案是什么呢？我已经忍不住要说了啊啊啊 解决方案就是把行为behavior（即这里的eat和paly）抽取出来，然后定义一组实现该行为的类，Animal拥有这些实现类的对象，并提供对应的setter用于动态修改这些行为。 直接看示例： Animal class: package org.kuilz.StrategyPattern.upgrade; public class Animal { public String name; private EatBehavior eatBehavior; public Animal(){} public Animal(String name){ this.name=name; } public void setEatBehavior(EatBehavior eatBehavior){ this.eatBehavior=eatBehavior; } public void performEat(){ eatBehavior.eat(this.name); } } Cat class: package org.kuilz.StrategyPattern.upgrade; public class Cat extends Animal { public Cat(){} public Cat(String name){ super(name); } } Dog class: package org.kuilz.StrategyPattern.upgrade; public class Dog extends Animal { public Dog(){} public Dog(String name){ super(name); } } EatBehavior interface: package org.kuilz.StrategyPattern.upgrade; public interface EatBehavior { public abstract void eat(String name); } EatFish class: package org.kuilz.StrategyPattern.upgrade; public class EatFish implements EatBehavior{ @Override public void eat(String name) { System.out.println(name+\": \"+\"I am eating fish.\"); } } EatMeat class: package org.kuilz.StrategyPattern.upgrade; public class EatMeat implements EatBehavior{ @Override public void eat(String name) { System.out.println(name+\": \"+\"I am eating meat.\"); } } EatBone class: package org.kuilz.StrategyPattern.upgrade; public class EatBone implements EatBehavior{ @Override public void eat(String name) { System.out.println(name+\": \"+\"I am eating bones.\"); } } Main function: package org.kuilz.StrategyPattern.upgrade; import java.util.ArrayList; import java.util.List; public class Demo { public static void main(String[] args) { EatBehavior eatFish = new EatFish(); EatBehavior eatBone = new EatBone(); EatBehavior eatMeat = new EatMeat(); Animal cat = new Cat(\"Garfield\"); cat.setEatBehavior(eatMeat); cat.performEat(); List eatBehaviors=new ArrayList\u003c\u003e(); eatBehaviors.add(eatFish); eatBehaviors.add(eatBone); eatBehaviors.add(eatMeat); Animal dog = new Dog(\"Snoopy\"); for(EatBehavior eatBehavior:eatBehaviors){ dog.setEatBehavior(eatBehavior); dog.performEat(); } } } Output: Garfield: I am eating meat. Snoopy: I am eating fish. Snoopy: I am eating bones. Snoopy: I am eating meat. 这样就实现了动态修改，想吃什么吃什么（hhh是不是能看出来我更喜欢狗子。 EatBehavior我已经实现好啦，你可以试着实现PlayBehavior，源码放在github上，可以修改或运行一下加深印象。（如果点个⭐就更好啦😁） 最后说一下策略模式的定义： The Strategy Pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it. 策略模式定义了一系列算法，每一个都单独封装起来，并使它们可以相互替换。策略模式使算法能够独立于使用它的客户而变化。 总结来说没什么可总结的，就是字面意思：定义一系列算法或者说一组类，这些类可以相互替换，从而实现了代码复用和动态变化。 书中有一个示例可以加深理解，试一下你能不能秒懂！ Character is the abstract class for all the other characters (King, Queen, Knight, and Troll), while WeaponBehavior is an interface that all weapon behaviors implement. So all actual characters and weapons are concrete classes. To switch weapons, each character calls the setWeapon() method, which is defined in the Character superclass. During a fight the useWeapon() method is called on the current weapon set for a given character to inflict great bodily damage on another character. 这个示例就是国王和王后等不同角色均继承（IS-A）自Character，Character拥有（HAS-A）WeaponBehavior的实例，以及设置该实例的setter方法。WeaponBehavior是一个接口，有一组实现类。各种角色可以在运行时动态修改使用的武器。 附录：适合中国宝宝体质的笔记 声明：以下内容非原创，定义出自《Head First Design Pattern》，类图和JDK出自Java 全栈知识体系。 定义 The Strategy Pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it. 策略模式定义了一系列算法，每一个都单独封装起来，并使它们可以相互替换。策略模式使算法能够独立于使用它的客户而变化。 类图 Strategy 接口定义了一个算法族，它们都具有 behavior() 方法。 Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(in Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。 JDK java.util.Comparator#compare() javax.servlet.http.HttpServlet javax.servlet.Filter#doFilter() （这些实现我还没看过。。。） 参考 Code Repo 《Head First Design Pattern》 Java 全栈知识体系 ","title":"设计模式——策略模式","uri":"/blog/2024/05/design_pattern_strategy_pattern/"},{"content":"本来想写年度总结呢，但我太喜欢反思了，导致写的内容不是客观描述做的事情、学的东西，而是充满了琐碎细节和吐槽。年度总结留着自己看吧，在这里分享一下轻松愉快的颁奖环节。\n读书 最佳文学奖\n余华的《在细雨中呼喊》，模仿记忆叙事，想象天马行空，叙事洒脱随性，读起来很奇妙！\n最佳计算机科学奖\n《硅谷之火》，一部个人计算机的发展史，记录了PC时代巨头和大佬们的成长。\n最佳作者奖\n刘震云，今年读了他的《故乡天下黄花》和《我叫刘跃进》，觉得刘老师一直稳定发挥，作品平均质量很高，还没发现让人不太满意的作品。\n特别贡献奖\nz-library\n知识应该是免费的，可以自由传播的。当然，知识产权也理应得到保护，但不该用金钱筑起知识的壁垒。发展到现在，且不谈书籍，科研论文竟然都不能被人们免费获取，实在难以理解，人类最先进的科研成果难道不应该被全体人类免费共享吗？知识应当像教育和医疗一样，作为国家提供的基础设施，创作者的收益由集体支付。\n听歌 最佳华语单曲\n陈奕迅的十面埋伏（现在的博客太简陋了😂，后面要把音乐播放器嵌入进来）\n最佳华语歌手\n恭喜Eason，蝉联三年！\n最佳外语单曲\nEd Sheeran的Supermarket Flowers\n最佳外语歌手\nColdplay，强推Viva La Vida，Taylor翻唱的也很好听。比较奇妙的是，最近几天听到了Eason翻唱的Yellow，属于本站最佳华语歌手与最佳外语歌手的碰撞🐶。\n影视 最佳电影\n《天堂电影院》，童年，忘年交，电影，初恋，遗憾，都很美好。\n最佳日漫\n《进击的巨人》，完结撒花🎉谁能想到我竟然是因为巴以冲突开始看这部动漫的，没想到世界上竟然存在加沙这种大型监狱，以色列当年建国得到承认已经够魔幻的啦。略略略，动漫很好看。\n最佳美漫\n《万神殿 》，今年就不颁给《瑞克和莫蒂》了，提携一下新人😎。Uploaded Intelligence的创意很好，但关于政治的刻板印象和意淫有点多。\n颁奖典礼到此结束。\np.s. 以后可以在豆瓣记录下读书和观影历史。\n对了，新年快乐呀~\n","title":"2023 kuilz 年度最佳","uri":"/post/2023/12/2023_annual_summary/"},{"content":"甬江江畔的风终于消停些了，今天中午阳光很暖。走在去食堂的路上，阳光让心情也逐渐升温，变得有些愉悦。同样的温暖和愉悦让我想起多年前我站在家门口，顺着大路向北张望，等待奶奶回家的那个遥远的中午。\n电影《一九四二》里，传教士安子一句“起初，摩西带领以色列人逃出埃及，今天，我带领你们走出河南”，让人印象深刻。《一句顶一万句》中意大利传教士老詹，为杨百顺取名杨摩西，开启了他出走的故事。刘震云的作品常常出现基督教的人物，这是因为他喜欢把故事设定在自己的家乡——河南延津。很多人不了解的是，河南拥有全国最多的基督教信徒。在某种意义上，奶奶也是一个基督徒。\n小时候爸妈外出打工，由奶奶带我。每到周日，奶奶都会去离家三里路的刘大庄守礼拜，有时也会把我带过去。但我觉得他们祷告、唱歌什么的没意思，多半坐不了多久就跑出去和一帮不认识的小朋友玩去了。守礼拜的地方并不是教堂，起码看起来不是。那是一个普通的农家宅院，堂屋门一般会锁上，西边的三间偏房专门用来给大家守礼拜。“教堂”是除了学校之外唯一有粉笔的地方，我和其他小朋友拿着捡来的粉笔头在墙上乱画，大一点的小朋友会写一些字，我当时估计还没把拼音认全。当乱涂乱画对我不再有吸引力的时候，我就很少跟着奶奶去守礼拜了，即使是圣诞节也不去，就算是圣诞节也不去！\n那天，我站在家门口，顺着大路向北望，等奶奶回家。奶奶一定在早上就告诉我今天是圣诞节了，走过来时，一见到我她就从一个口袋里掏出一包方便面，然后从另一个口袋里掏出几个糖果。听奶奶说她们在教堂还会喝一杯葡萄酒，那是什么美味我还没品尝过，好在我当时已经“成熟”到不会为了一杯葡萄酒去守礼拜了。圣诞节在我的印象中一直是方便面、糖果和没尝过的葡萄酒，直到现在我还不知道在这对于基督徒最重要的一天，她们做的事情会不会和平常有些不一样，可惜我也不会知道了，因为不再有机会可以问奶奶。\n斯人已逝，生者长思。圣诞快乐，Merry Christmas。对我来说，纪念奶奶的最佳方式就是在冬天穿得暖和点，把领口的拉链再往上拉点。“一层布一层风，十层布过一冬，别挟喽怀”，对吧。\n","title":"圣诞快乐","uri":"/post/2023/12/merry_christmas/"},{"content":"写下这段文字是因为突然发现大脑输入信息的速度比我想的还要慢得多。\n缘起 闲来没事在google scholar看一位年轻博后的主页时，发现他23年的一篇新文章竟然引用量比之前发的都高很多。不知怎么，我突然想知道google scholar上引用量最高的人和文章分别是什么。（如果你觉得这两句话没什么逻辑，我深表同意\u0026抱以歉意，可过程就是这样，只能怪思维比较跳跃，缺乏逻辑）\n谈到引用量最高的人和文章，脑子里首先跳出来的是Kaiming He和他的ResNet，搜索发现总引用量是50个w，ResNet单篇引用量竟然足有19个w！！！\n一激动就开始水群，把ResNet引用量的截图甩到群里，说“这几年深度学习发了多少文章可见一斑”，朋友说听李沐讲去年一年就发了30万篇AI的论文。30万篇，八辈子都看不完，好在我不是做AI的哈哈，但情况是一样的：吾生也有涯，而知也无涯。以有涯随无涯，殆已！\n那么就只能祈祷LLM快速发展，让它读几十万篇论文，然后我问它问题就好啦，因为我阅读的速度太慢了，或者说人脑输入信息的速度太慢了！\n过程 人脑输入信息的速度太慢了，那么到底有多慢呢？我想简单测一下。于是把眼前这篇论文的摘要复制粘贴进word，统计出来这段话包括183个单词，共计1339个字符（计空格）。\n读这段摘要用了1分20秒，虽然平时肯定不会这么读。以字符计算，1339个字符读了80秒，每个字符按UTF-8编码的话，只占用一个字节。所以很明显我的阅读速度约为16 Byte/s。怎么评价这个速度？如果一个U盘速度是这么快，掉地上我都不带捡的呜呜呜😭😭😭\n而且我一直觉得阅读文本是大脑输入信息最快的方式，用眼睛看比用耳朵听已经快多了。以至于当我以获取信息为目的看某段视频，但那段视频磨磨唧唧大多都是废话时，我可能会把直接导出字幕，然后看字幕的文本文件。\n结语 所以说，大脑输入信息的速度真是慢的让人难以接受。人类进行信息输入和输出的效率如此低，而且不管是输入还是输出都是有损的——花80秒读的摘要在我敲下这行字时已经忘光了（输入有损），就算我记住，如果讲给别人的话，别人接收到的也会比我输出的少得多（输出有损），甚至他可能压根不想搭理我，直接左耳朵进右耳朵出了😂\n写到这儿有两点想法：\n一是肉体苦弱，机械飞升，什么时候脑机接口能够发展到把知识输入人脑的过程变得像把硬盘插进电脑一样简单？研究脑机接口的朋友说现在早着呢，还远没到那个阶段。我当然知道，而且即便到了那个时候率先享受这一科技的肯定是富人，借此富人可以直接不需要学习，就获得人类的所有知识，和我这种16 B/s的穷人分化成两个物种。\n二是像我前面说的既然人类进行信息输入和输出的效率如此低，怎么还能创造出这么多强大美妙的东西呢？直觉告诉我，我们的大脑不擅长进行信息的输入和输出，它擅长的是别的处理。那么大脑擅长什么呢？尤其是和我们已经创造出的用于进行存储和计算的机器相比。 这个问题我暂时懒得思考哈哈，反正后面会有机会瞎想的。\n参考 https://scholar.google.com/citations?user=DhtAFkwAAAAJ\u0026hl=en Luo X, Wang H, Wu D, et al. A Survey on Deep Hashing Methods[J]. ACM Transactions on Knowledge Discovery from Data, 2023, 17(1): 1-50. ","title":"我的废物大脑","uri":"/post/2023/12/how_slowly_the_brain_inputs_information/"},{"content":"我出生在豫东平原的一个小村庄，不是村里第一个大学生，但应该是村里第一个研究生。每次寒暑假回家都会遇到一位老大爷，远远看到我时他会先发声：“大学生回来啦，好好学，以后咱XX庄也出个大官，混好喽白忘了给庄里修条路。”或者问些毕业分不分配工作之类的问题，尽管我一再解释说现在都是自己找工作，但他总是记不得。\n他不会知道也很难理解，我上学跟当官甚至分配就业都没什么关系，对我来说最好的出路大概是在某个厂的格子间里，整天盯着几块屏幕伸着脖子敲代码而已（不要头前伸😠）。\n上世纪九十年代初，大学生就业包分配制度逐渐过渡为双向选择，并于1999年前后全面停止包分配，进入市场化竞争。但党的领导仍然是中国特色一流大学治理体系的首要特征，这当然是一种优势，不然如果大学也全面市场化，那我大概率上不起学，已经在工地打灰儿了。然而，高等教育的管理核心是中国特色社会主义制度，但高等教育下的学生面对的是全面市场化的竞争，家庭背景不同造就的文化差异使得部分学生难以理解和适应大学校园的游戏规则。书中根据行为模式将个体分为“目标掌控者”和“直觉依赖者”，论证了二者并不是个体自由选择的结果而是阶层习性的产物，是在潜移默化中形成的，是不同阶层成员日用而不知的。而大学的评价标准更有利于“目标掌控者”获得职业优势，从而促进了学生出路不平等的产生。\n如果说毕业后的出路选择是一道优化问题的话，那么每个人不同的家庭背景是这一问题所具有的重要约束条件。更可怕的是“直觉依赖者”可能并没有意识到这是一个优化问题，他们不是在有意识地选择，而是在无意识中被选择。在漫无目的地来到毕业出口时，随手抓住一个自己够得着的机会，然后被人流裹挟着涌入人海。\n书中，作者将社会出身弱势分为以下四个维度的劣势：\n家庭社会经济地位(SES)属于低收入群体或较低阶层（例如父母职业为工人、体力劳动者或无业）; 来自农村的学生; 来自西部偏远地区的学生; 第一代大学生，即父母双方均未受过高等教育的学生。 若一个学生存在上述三种及以上的劣势，则在本研究中被统计作“明显劣势”；存在两种劣势，则视作“部分劣势”；存在一种劣势，则视作“轻微劣势”；若完全不存在上述四种劣势中的任何一种，则视作“明显优势”。\n如果你像我一样刚好处于明显劣势，该怎么做呢？总结来说，作者给出的建议大概有如下几点：\n意识到自己所经历的困境并非自身能力或性格缺陷引起的，而是有规律可循的社会事实。 挑战自己习以为常的观念和生活方式，接受（或至少经过反思后拒绝）那些总是不假思索就拒绝的观念和事物。 为自己创造多元化的社交机会，尽可能广泛地接触新观念和新做法。 …… 写不下去了哈哈😂，越写越像鸡汤文，写了这么多我也做不到。在我看来，比较适合我方法是①发现自己陷入困境时，停下来想想为什么我的方法失效了？是不是需要改变点什么？②有些事情看不惯就不做呗，大概率也不是非做不可的，如果是非做不可的，那么就会变成第①种情况。\n不同文化习性下会形成的不同道德感，包括道德信念和道德判断，这很难改变，不如顺其自然。我的想法也同作者不谋而合，她说“要在向上攀登的蜕变之路上仍保持原先自我的延伸性，而非与过去的自己彻底决裂”。\n参考：\n金榜题名之后：大学生出路分化之谜 待业、择业、创业：我国青年就业机制的演变 ","title":"金榜题名之后：大学生出路分化之谜-读书随笔","uri":"/post/2023/10/university_education/"},{"content":"书中讲述的上百人的故事基本没有自然死亡的，虽然有人统计过余华的作品中从来不缺少非自然死亡的人物，但这本书直接讲述的是死者之间的对谈。 从死者的对谈中，我们得以了解他们生前的遭遇。每个死亡背后都是一段苦难的生活，作者毫不避讳地、使用笨拙质朴的语言描述现实的苦难，竟使现实显得离奇荒诞，戏谑魔幻。可能有人觉得书中的故事离我们过于遥远，但我清楚且相信这就是很多人现实生活的写照。\n2020年5月28日，前国务院总理李克强在出席记者会并回答中外学者提问的过程中提到：我国有六亿人每月收入低于1000元。\n即便如此，我们仍能从本书中感受到温情，苦难生活里，亲情是一剂止痛药。这里的“亲情”包括“爱情”，请原谅我奇怪且个人的归类。杨飞在杨金彪超越血缘关系的疼爱中成长起来，他对妻子李青的宽容也继承自父亲。刘梅和伍超彼此相爱、互相搀扶。他们一个美丽、一个聪明，却仍蜗居在废弃的地下室成为鼠族，见不到阳光和月光，好在彼此的相伴和关爱为他们的生活带来了光亮。“诚知此恨人人有，贫贱夫妻百事哀”，从爱情扩展回亲情的话，我想亲情为处于苦难生活中的我们带来了美好，而苦难生活也使得亲情更加坚固。\n坦白说，刚读这本书时，我还在想读完之后要怎么吐槽——觉得这本书远低于余华的平均水准。语言笨拙且零散，这种零散绝不是洒脱随性，《在细雨中呼喊》模仿回忆漫无边际地叙事才是我说的洒脱随性。当时觉得这本书除了背景设置有些魔幻之外，其他一无是处。后来才慢慢因为书中对感情描写的比较丰满而有了些好感，关于杨飞和杨金彪死后初次相遇并没有认出对方的设计也让我眼前一亮，有些触动。总的来说，这本书还是值得一读的。\n","title":"苦难生活里亲情是一剂止痛药——读《第七天》","uri":"/post/2023/08/day_7/"},{"content":"文学与窥私欲是这部剧的两条线，吉尔曼发现了克劳德的文学天分，是他和克劳德共同完成了这部作品。克劳德潜入朋友家中，近距离窥探对方一家的生活，同时吉尔曼也在窥视着这家人，如同审视自己的作品。\n不由得让我怀疑阅读文学作品本身是不是也夹杂着窥私欲，毕竟一览无余的上帝视角让人难以抗拒。每扇窗的背后都有一个故事，可以阅读别人的故事，但更重要的是关心自己晚饭吃什么。\n","title":"文学与窥私欲——观《登堂入室》","uri":"/post/2023/08/dans_la_maison/"},{"content":"不知道为什么这本书这么火，可能是由于和弗洛伊德式的“原因论”不同，本书强调的是“目的论”，即认为起决定作用的是你自己，这一观点可以在目前社会经济环境状况不佳的情况下给人些许动力。\n书中内容并没有给我留下太多印象，一方面是我记忆力不太好，另一方面是我始终认为“读书无用”，因此我总是以一种近乎消遣的方式读书，甚至没怎么关心书的主题，而是更青睐于书中任意内容与我的想法产生的零星碰撞。\n此处的“零星碰撞”就是书中提到的“自我接纳”了。\n自我接纳是指假如做不到就诚实地接受这个“做不到的自己”，然后尽量朝着能够做到的方向去努力，不对自己撒谎。\n对得了60分的自己说“这次只是运气不好，真正的自己能得100分”，这就是自我肯定；与此相对，在诚实地接受60分的自己的基础上努力思考“如何才能接近100分”，这就是自我接纳。\n最近，我常常对自己进行心理暗示，告诉自己要承认两点：\n承认自己很菜的事实。 承认自己在努力变强的事实。 这两点竟然恰如其分地对应书中的前半句（诚实地接受这个“做不到的自己”）和后半句（朝着能够做到的方向去努力）。对我来说，承认自己很菜是比较难的，一是因为动物本能地都会掩饰自己的弱项吧。二是自我意识过剩，担心自己会被嘲笑，其实倒也没人那么关注你。这一点无需多言，我想主要谈谈第二点——承认努力。有时候承认自己在努力可能也是一件难事儿，为什么呢？我觉得我们的文化中对“举重若轻”有一种特别的迷恋，大家更喜欢天才，喜欢不费吹灰之力就能取得成功的天才。因此，在某种程度上，努力代表着愚笨；而且在这个人们张口闭口都是“内卷”的时代，努力还代表内卷，让人避之不及。文化的崇尚和社会的风气都是客观环境，起决定作用的还是我们自己，所以自我接纳和理性选择就比较重要了，可以让我们轻松点、幸福点。\n另外，尽管总能听到“过程比结果更重要”的言论，但书中关于过程的论述还是刺痛到了我。\n假如人生是为了到达山顶的登山，那么人生的大半时光就都是在“路上”。也就是说，“真正的人生”始于登上山顶的时候，那之前的路程都是“临时的我”走过的“临时的人生”。\n目标明确的人更容易忽略过程，这段话与诸君共勉，我觉得登上山顶太晚了，希望我们的人生从今天就开始。\n","title":"自我接纳——读《被讨厌的勇气》","uri":"/post/2023/08/self-acceptance_the_courage_to_be_disliked/"},{"content":"小时候喜欢掏鸟钓鱼扒螃蟹，写下这三件事时我还在想为什么是钓鱼而不是摸鱼？大概是因为我太菜了，钓鱼相对于摸鱼更安全，也更没技术含量，还不会弄脏衣服挨骂。那时候还买不起鱼竿，没什么比一根长长的竹子更有吸引力了。同学在我的软磨硬泡下答应在他家给我砍一根，于是我骑着总掉链子的自行车，走走停停骑完了七八里路，到了他家。但结局并没那么完美，他只砍了一棵竹子，还被另一个同学和他哥哥一起抢走了，他不再有竹子可以给我，我只得空手而归。\n夏天的暴雨过后比较容易捡到雏鸟。因为大风不仅能把鸟窝吹飞，还能把枝干折断，我获得的鸟中大多来自这一途径。因为我不会爬很粗的树，一般会找鸟窝，然后怂恿一些高手去掏，如果雏鸟比较多的话我就能分到一个，权当介绍费了。有次暴雨后的早上，姥爷神秘地跟我说水槽角有个好东西，让我去看看，我跑到水槽边掀开破布看到了两只小斑鸠。另一个暴雨过后的日子，我寻着鸟叫翻过窗户从废纸堆里也捡到一只小鸟，是不是白头翁我记不清了。我把它放在课桌兜里，放学后一路跑回去送给了爷爷，爷爷让我去捡了几颗桑葚喂它。\n感觉自己像在写小学作文，我也挺希望这段文字是当时写下的呢。记忆中河边的那棵桑葚树一直没有变粗，而且结的桑葚也越来越少了。\n","title":"关于童年的一些记忆碎片","uri":"/post/2023/08/some_memories_of_childhood/"},{"content":" update_time: 2024-09-28 About Me 你好呀~我叫kuilz，kuilz是我在网络上的昵称。它不是英文名，很明显也不是中文名，只是五个字母的随机组合，不过我觉得这样排列有一点好看。\n还是忍不住告诉你，我的名字单字一个魁，我很喜欢这个名字，因为它是我永远怀念的姥姥取的。“魁”的意思是“为首的，居第一位的”，但我不喜欢为首，也很少拿第一，有时候这让我感到忧伤。\n我不善言辞，打起字来却很啰嗦，就像我上面写了这么多才介绍了名字而已。生活中的我往往刚说了名字和籍贯，就忍不住“谢谢大家”了。所以我觉得有必要用不同于真名的昵称——kuilz作为我的数字身份。\n虽然标签容易产生误解，但不得不承认它仍是最快了解一个人的方式之一。\nMe in 10 Seconds\n👨‍🚀河南农村人。家有四亩地，秋天种小麦，夏天种玉米。\n👨‍💻浙大软工硕士在读。正在从跟着指挥棒卷分数的同学，变成有想法有实力的极客。\n🥷终身学习者。因为无知，且好奇。\nSome Links email github 知乎 ","title":"About","uri":"/about/"},{"content":"The searching is performed via fuse.js. For the search keywords, white spaces act as the AND operator, and | acts as the OR operator. To match an exact phrase, double quote it. For example, R Markdown matches articles that contain both R and Markdown, R | Markdown matches articles that contain R or Markdown, and \"R Markdown\" matches articles that contain the whole phrase R Markdown.\n","title":"Search","uri":"/search/"}]